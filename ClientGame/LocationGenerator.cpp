#include "stdafx.h"
#include "LocationGenerator.h"

namespace
{
	const auto maxCityAttemptsFallBack = 10;
	const auto maxLocationAttemptsFallBack = 10;
	const auto cityRadiusFallBack = 50.0f;
	const auto locationRadiusFallBack = 50.0f;
	const auto mapSizeXFallBack = 10000;
	const auto mapSizeYFallBack = 10000;
}

LocationGenerator::LocationGenerator()
{
	GetPreferenceData();
	GetMapSize();
}

LocationGenerator::~LocationGenerator()
{
}

void LocationGenerator::GetMapSize()
{
	// Get Map Size.
	mapHalfSize = mapSize / 2;
}

void LocationGenerator::GetPreferenceData()
{
	// Grab max attempt number for cities.
	maxCityAttempts = thePrefs.GetInt("CityGeneratorSettings", "maxAttempts");
	if (!maxCityAttempts) // If 0 then use fallback value.
		maxCityAttempts = maxCityAttemptsFallBack;

	// Grab city radius
	cityRadius = thePrefs.GetFloat("CityGeneratorSettings", "cityRadius");
	if (!cityRadius) // If 0 then use fallback value.
		cityRadius = cityRadiusFallBack;

	// Grab max attempt number.
	maxLocationAttempts = thePrefs.GetInt("LocationGeneratorSettings", "maxAttempts");
	if (!maxLocationAttempts) // If 0 then use fallback value.
		maxLocationAttempts = maxLocationAttemptsFallBack;

	// Grab city radius
	locationRadius = thePrefs.GetFloat("LocationGeneratorSettings", "locationRadius");
	if (!locationRadius) // If 0 then use fallback value.
		locationRadius = locationRadiusFallBack;

	auto mapSizeX = thePrefs.GetInt("LocationGeneratorSettings", "mapSizeX");
	if (!mapSizeX)
		mapSizeX = mapSizeXFallBack;

	auto mapSizeY = thePrefs.GetInt("LocationGeneratorSettings", "mapSizeY");
	if (!mapSizeY)
		mapSizeY = mapSizeYFallBack;

	mapSize = Vec2i(mapSizeX, mapSizeY);
}

Vector2 LocationGenerator::RandomPosInMap()
{
	// Generate location
	// Positions are generated by offsetting from the middle of the map as to avoid corner clutter.
	return Vector2(MathUtil::RandomIntInRange(-mapHalfSize.X, mapHalfSize.X),
		MathUtil::RandomIntInRange(-mapHalfSize.Y, mapHalfSize.Y));
}

Vector2 LocationGenerator::GeneratePosition(int mode, std::vector<std::shared_ptr<City>>& refCityContainer, std::vector<std::shared_ptr<Location>>& refLocationContainer)
{
	Vector2 position = Vector2(0.0f, 0.0f);

	bool ruleFail = false; // Boolean value to show if any of the generation rules failed.
	auto maxAttempts = 0;
	auto radius = 0.0f;

	switch (mode)
	{
	case 1:
		maxAttempts = maxCityAttempts;
		radius = cityRadius;
		break;

	case 2:
		maxAttempts = maxLocationAttempts;
		radius = locationRadius;
		break;

	default:
		maxAttempts = maxCityAttempts;
		radius = cityRadius;
		break;
	}

	// Generate city info.
	for (auto i = 0; i < maxAttempts; i++)
	{
		ruleFail = false;
		position = RandomPosInMap();

		// Check if location is valid.
		for (std::weak_ptr<City> i : refCityContainer)
		{
			auto distance = sqrt(pow(position.X - i.lock()->GetPosition().X, 2) + pow(position.Y - i.lock()->GetPosition().Y, 2));
			if (distance <= radius)
			{
				ruleFail = true;
				break;
			}
		}

		for (std::weak_ptr<Location> i : refLocationContainer)
		{
			auto distance = sqrt(pow(position.X - i.lock()->GetPosition().X, 2) + pow(position.Y - i.lock()->GetPosition().Y, 2));
			if (distance <= radius)
			{
				ruleFail = true;
				break;
			}
		}

		// If it is valid then return the position.
		if (ruleFail)
			sysLog.Log("Failed to Generate location at position: " + Vector2ToString(position));
		else
			return position;
	}

	return NULL; // Could not find a city location.
}