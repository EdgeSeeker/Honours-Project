#include "stdafx.h"
#include "TheGameManager.h"

namespace
{
	const int cityNumFallBack = 10;
	const int locationNumFallBack = 10;
	const int maxAttemptsFallBack = 10;
	const float cityRadiusFallBack = 50.0f;
	const float locationRadiusFallBack = 50.0f;
}

TheGameManager* TheGameManager::_instance = NULL;

TheGameManager& TheGameManager::getInstance()
{
	if (_instance == NULL)
		_instance = new TheGameManager();
	return *_instance;
}

TheGameManager::TheGameManager()
{
	mapSize = halfMapSize = Vector2(0.0f, 0.0f);

	uiManager.reset(new UIManager());

	GenerateMap();
}

void TheGameManager::Render()
{
}

void TheGameManager::Update(float dt)
{
	uiManager->Update();
}

void TheGameManager::GenerateMap()
{
	// Get Map Size.
	mapSize = Vector2(thePrefs.GetFloat("Map", "width"), thePrefs.GetFloat("Map", "height"));
	halfMapSize = mapSize / 2;

	// Get number of cities to be generated.
	int cityNum = thePrefs.GetInt("MapGeneratorSettings", "cities");
	if (!cityNum)
		cityNum = cityNumFallBack;

	// Get number of locations to be generated.
	int locationNum = thePrefs.GetInt("MapGeneratorSettings", "locations");
	if (!locationNum)
		locationNum = locationNumFallBack;

	GenerateCities(cityNum);
	GenerateLocations(locationNum);
}

void TheGameManager::GenerateCities(int cityNumber)
{
	// Variables
	Vector2 cityPosition = Vector2(0.0f, 0.0f);
	bool ruleFail = false; // Boolean value to show if any of the generation rules failed.
	float distance = 0.0f;

	// Grab max attempt number.
	auto maxAttempts = thePrefs.GetInt("CityGeneratorSettings", "maxAttempts");
	if (!maxAttempts) // If 0 then use fallback value.
		maxAttempts = maxAttemptsFallBack;

	// Grab city radius
	auto cityRadius = thePrefs.GetFloat("CityGeneratorSettings", "radius");
	if (!cityRadius) // If 0 then use fallback value.
		cityRadius = cityRadiusFallBack;

	for (auto i = 0; i < cityNumber; i++)
	{
		// Crate a new City.
		std::unique_ptr<City> newCity;
		newCity.reset(new City());

		// Generate city info.
		for (auto i = 0; i < maxAttempts; i++)
		{
			// Generate location
			// Positions are generated by offsetting from the middle of the map as to avoid corner clutter.
			cityPosition.X = static_cast<int>(MathUtil::RandomIntInRange(-halfMapSize.X, halfMapSize.X));
			cityPosition.Y = static_cast<int>(MathUtil::RandomIntInRange(-halfMapSize.Y, halfMapSize.Y));

			// Check if location is valid.
			// RULES:
			for (std::vector<std::unique_ptr<City>>::iterator i = cityContainer.begin(); i != cityContainer.end(); ++i)
			{
				// 1) Farther than the radius of another city.
				distance = sqrt(pow(cityPosition.X - i->get()->GetPosition().X, 2) + pow(cityPosition.Y - i->get()->GetPosition().Y, 2));
				if (distance >= cityRadius)
					ruleFail = false;
				else
				{
					ruleFail = true;
					break;
				}
			}

			// If it is valid then move on to generate the rest of the info
			if (!ruleFail)
				break;
			else // Else regenerate position and check again.
				sysLog.Log("Failed to Generate position at: " + std::to_string(static_cast<int>(cityPosition.X)) + "X, " + std::to_string(static_cast<int>(cityPosition.Y)) + "Y.");
		}

		newCity->SetPosition(cityPosition);

		// Move the city into the container.
		cityContainer.push_back(std::move(newCity));
	}
}

void TheGameManager::GenerateLocations(int locationNum)
{
	// Variables
	Vector2 locationPosition = Vector2(0.0f, 0.0f);
	bool ruleFail = false; // Boolean value to show if any of the generation rules failed.
	float distance = 0.0f;

	// Grab max attempt number.
	auto maxAttempts = thePrefs.GetInt("LocationGeneratorSettings", "maxAttempts");
	if (!maxAttempts) // If 0 then use fallback value.
		maxAttempts = maxAttemptsFallBack;

	// Grab city radius
	auto locationRadius = thePrefs.GetFloat("LocationGeneratorSettings", "radius");
	if (!locationRadius) // If 0 then use fallback value.
		locationRadius = locationRadiusFallBack;

	for (auto i = 0; i < locationNum; i++)
	{
		// Crate a new City.
		std::unique_ptr<Location> newLocation;
		newLocation.reset(new Location());

		// Generate city info.
		for (auto i = 0; i < maxAttempts; i++)
		{
			// Generate location
			// Positions are generated by offsetting from the middle of the map as to avoid corner clutter.
			locationPosition.X = static_cast<int>(MathUtil::RandomIntInRange(-halfMapSize.X, halfMapSize.X));
			locationPosition.Y = static_cast<int>(MathUtil::RandomIntInRange(-halfMapSize.Y, halfMapSize.Y));

			// Check if location is valid.
			// RULES:
			// 1) Farther than the radius of another city.
			for (std::vector<std::unique_ptr<City>>::iterator i = cityContainer.begin(); i != cityContainer.end(); ++i)
			{
				distance = sqrt(pow(locationPosition.X - i->get()->GetPosition().X, 2) + pow(locationPosition.Y - i->get()->GetPosition().Y, 2));
				if (distance < locationRadius)
				{
					ruleFail = true;
					break;
				}
			}

			// 2) Farther than the radius of another location.
			// Check if the first rule has failed or not.
			if (!ruleFail)
			{
				// If it hasn't then move on to check rule 2.
				for (std::vector<std::unique_ptr<Location>>::iterator i = locationContainer.begin(); i != locationContainer.end(); ++i)
				{
					distance = sqrt(pow(locationPosition.X - i->get()->GetPosition().X, 2) + pow(locationPosition.Y - i->get()->GetPosition().Y, 2));
					if (distance < locationRadius)
					{
						ruleFail = true;
						break;
					}
				}
			}

			// If it is valid then move on to generate the rest of the info
			if (!ruleFail)
				break;
			else // Else regenerate position and check again.
				sysLog.Log("Failed to Generate position at: " + std::to_string(static_cast<int>(locationPosition.X)) + "X, " + std::to_string(static_cast<int>(locationPosition.Y)) + "Y.");
		}

		newLocation->SetPosition(locationPosition);

		// Move the city into the container.
		locationContainer.push_back(std::move(newLocation));
	}
}
